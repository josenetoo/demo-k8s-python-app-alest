TASKS: Deploying Hello-World Application to Kubernetes
Este documento fornece instru√ß√µes passo a passo para conteinerizar uma aplica√ß√£o "hello-world" usando Docker (se necess√°rio) e implant√°-la em um cluster Kubernetes, tornando-a acess√≠vel externamente na porta 8080.

Pr√©-requisitos üìã
Docker Instalado: Certifique-se de que o Docker Desktop ou Docker Engine esteja instalado e em execu√ß√£o.

Verificar:

docker --version

Instala√ß√£o: Obter Docker

kubectl Instalado: A ferramenta de linha de comando do Kubernetes.

Verificar:

kubectl version --client

Instala√ß√£o: Instalar kubectl

Acesso a um Cluster Kubernetes: kubectl deve estar configurado para se comunicar com seu cluster.

Verificar:

kubectl cluster-info

ou

kubectl get nodes

Pode ser Minikube, kind, Kubernetes do Docker Desktop ou um servi√ßo Kubernetes de provedor de nuvem (GKE, EKS, AKS).

Conta em um Registro de Cont√™iner (Opcional, mas Recomendado):

Uma conta no Docker Hub se voc√™ planeja construir e enviar uma imagem personalizada. Para usar uma imagem p√∫blica pr√©-constru√≠da como nginxdemos/hello, isso n√£o √© estritamente necess√°rio para puxar a imagem, mas √© uma boa pr√°tica para futuras aplica√ß√µes personalizadas.

Se estiver usando um registro privado, certifique-se de que seu cluster Kubernetes esteja configurado com segredos de pull de imagem (image pull secrets).

Editor de Texto: Para criar e editar o Dockerfile (se necess√°rio) e os arquivos de manifesto YAML do Kubernetes.

Passo 1: Preparar a Aplica√ß√£o (Usando uma Imagem Pr√©-constru√≠da)
Para simplificar e focar nos aspectos do Docker e Kubernetes, usaremos uma imagem "hello-world" pr√©-constru√≠da do Nginx: nginxdemos/hello. Esta imagem serve uma p√°gina HTML simples na porta 80 dentro do cont√™iner.

Se voc√™ fosse usar uma aplica√ß√£o personalizada (ex.: uma aplica√ß√£o Python Flask):

Crie o c√≥digo da sua aplica√ß√£o (ex.: app.py).

Crie um requirements.txt (para Python).

Prossiga para o Passo 2 para criar um Dockerfile.

Passo 2: Conteinerizar a Aplica√ß√£o (Ignorado se estiver usando nginxdemos/hello)
Este passo s√≥ √© necess√°rio se voc√™ estiver construindo uma aplica√ß√£o personalizada. Como estamos usando nginxdemos/hello, esta imagem j√° est√° constru√≠da e dispon√≠vel no Docker Hub.

Se voc√™ estivesse construindo uma imagem personalizada (ex.: de uma aplica√ß√£o Python ouvindo na porta 5000):

2.1. Criar Dockerfile
No diret√≥rio raiz da sua aplica√ß√£o, crie um arquivo chamado Dockerfile.

# Exemplo para uma aplica√ß√£o Python Flask
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt requirements.txt
RUN pip install --no-cache-dir -r requirements.txt
COPY . .

EXPOSE 5000
CMD ["python", "app.py"]

2.2. Construir a Imagem Docker
Navegue at√© o diret√≥rio que cont√©m seu Dockerfile.

docker build -t seu-usuario-dockerhub/meu-app-hello:v1 .

(Substitua seu-usuario-dockerhub e meu-app-hello:v1 apropriadamente.)

2.3. Testar Localmente (Opcional, mas Recomendado)

docker run -p 5000:5000 seu-usuario-dockerhub/meu-app-hello:v1

Acesse http://localhost:5000.

2.4. Enviar para o Registro de Cont√™iner

docker login # Autentique-se com o Docker Hub ou seu registro escolhido
docker push seu-usuario-dockerhub/meu-app-hello:v1

Passo 3: Criar Manifesto de Deployment do Kubernetes üìú
Um Deployment do Kubernetes gerencia aplica√ß√µes stateless, garantindo que um n√∫mero especificado de r√©plicas (Pods) esteja em execu√ß√£o.

Crie um arquivo chamado hello-deployment.yaml:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-world-deployment      # Nome √∫nico para o Deployment
  labels:
    app: hello-world               # R√≥tulo para identificar recursos relacionados a esta app
spec:
  replicas: 2                      # N√∫mero desejado de inst√¢ncias da aplica√ß√£o (Pods)
  selector:
    matchLabels:
      app: hello-world             # Seletor para encontrar Pods gerenciados por este Deployment
                                   # Deve corresponder aos r√≥tulos no template do Pod
  template:                        # Template do Pod: define os Pods a serem criados
    metadata:
      labels:
        app: hello-world           # R√≥tulos aplicados a cada Pod
    spec:
      containers:
      - name: hello-world-container
        image: nginxdemos/hello:latest # A imagem Docker a ser usada.
                                       # Substitua pela sua imagem personalizada se voc√™ construiu uma
                                       # ex.: seu-usuario-dockerhub/meu-app-hello:v1
        ports:
        - containerPort: 80        # Porta em que a aplica√ß√£o *dentro do cont√™iner* escuta.
                                   # Para nginxdemos/hello, √© 80.
                                   # Para uma app Python personalizada na porta 5000, seria 5000.
        resources:                   # Opcional: Define requisi√ß√µes e limites de recursos
          requests:
            memory: "64Mi"
            cpu: "100m" # 0.1 n√∫cleo de CPU
          limits:
            memory: "128Mi"
            cpu: "250m" # 0.25 n√∫cleo de CPU

Campos chave:

metadata.name: Nome do objeto Deployment.

spec.replicas: N√∫mero de Pods a serem executados.

spec.selector.matchLabels: Como o Deployment encontra quais Pods gerenciar.

spec.template.metadata.labels: R√≥tulos aplicados aos Pods. Devem corresponder a spec.selector.matchLabels.

spec.template.spec.containers.image: A imagem Docker a ser executada.

spec.template.spec.containers.ports.containerPort: A porta exposta pelo cont√™iner. Isso √© crucial.

Passo 4: Criar Manifesto de Service do Kubernetes üåê
Um Service do Kubernetes fornece um ponto de extremidade de rede est√°vel (endere√ßo IP e porta) para acessar os Pods da aplica√ß√£o. Queremos expor a aplica√ß√£o externamente na porta 8080.

Crie um arquivo chamado hello-service.yaml:

apiVersion: v1
kind: Service
metadata:
  name: hello-world-service       # Nome √∫nico para o Service
  labels:
    app: hello-world              # R√≥tulo para identificar recursos relacionados a esta app
spec:
  type: LoadBalancer              # Exp√µe o Service externamente usando o balanceador de carga de um provedor de nuvem.
                                  # Alternativas: NodePort (para configura√ß√µes n√£o-nuvem ou espec√≠ficas), ClusterIP (apenas interno)
  selector:
    app: hello-world              # Seleciona Pods com este r√≥tulo para rotear o tr√°fego.
                                  # Deve corresponder aos r√≥tulos dos Pods no Deployment.
  ports:
    - name: http                  # Nome para a porta (opcional, mas boa pr√°tica)
      protocol: TCP
      port: 8080                  # Porta em que o Service estar√° dispon√≠vel *externamente*
                                  # e internamente no cluster no ClusterIP do Service.
      targetPort: 80              # Porta nos *Pods* para a qual o tr√°fego deve ser encaminhado.
                                  # DEVE corresponder ao containerPort no seu Deployment (ex.: 80 para nginxdemos/hello).
                                  # Se sua app dentro do cont√™iner escuta na 5000, defina como 5000.
      # nodePort: 30080           # Se type: NodePort, especifica a porta no IP de cada Node.
                                  # Intervalo: 30000-32767. Usado apenas se type for NodePort.
                                  # Se type for LoadBalancer, o provedor de nuvem geralmente escolhe isso ou √© gerenciado.

Campos chave:

spec.type: LoadBalancer √© prefer√≠vel para acesso externo em plataformas de nuvem. Se indispon√≠vel, mude para NodePort.

spec.selector: Deve corresponder aos r√≥tulos dos Pods gerenciados pelo seu Deployment.

spec.ports.port: A porta na qual o Service √© exposto. Clientes externos se conectar√£o a esta porta (ex.: http://<IP-LoadBalancer>:8080).

spec.ports.targetPort: A porta no cont√™iner para a qual o Service encaminha o tr√°fego.

Passo 5: Implantar no Cluster Kubernetes üöÄ
Certifique-se de que kubectl esteja configurado para o seu cluster de destino.

5.1. Aplicar o Manifesto de Deployment

kubectl apply -f hello-deployment.yaml

Sa√≠da esperada: deployment.apps/hello-world-deployment created

5.2. Verificar o Deployment
Verifique o status do Deployment:

kubectl get deployments hello-world-deployment

Aguarde at√© que as colunas READY e AVAILABLE mostrem a contagem de r√©plicas desejada (ex.: 2/2).

Verifique os Pods:

kubectl get pods -l app=hello-world

Voc√™ deve ver Pods com status Running. Pode levar um momento para as imagens serem puxadas e os cont√™ineres iniciarem.
Se houver problemas, use kubectl describe pod <nome-do-pod> e kubectl logs <nome-do-pod> para solucionar problemas.

5.3. Aplicar o Manifesto de Service

kubectl apply -f hello-service.yaml

Sa√≠da esperada: service/hello-world-service created

5.4. Verificar o Service e Obter IP/Porta Externa
Verifique o status do Service:

kubectl get services hello-world-service
# ou abreviado: kubectl get svc hello-world-service

Se TYPE for LoadBalancer:
Procure por EXTERNAL-IP. Pode levar alguns minutos para os provedores de nuvem atribu√≠rem um IP. Inicialmente, mostrar√° <pending>.
Sa√≠da de exemplo:

NAME                  TYPE           CLUSTER-IP    EXTERNAL-IP      PORT(S)          AGE
hello-world-service   LoadBalancer   10.96.45.30   34.XXX.YYY.ZZZ   8080:30080/TCP   2m

O ponto de acesso externo √© http://34.XXX.YYY.ZZZ:8080. A parte 30080 √© a nodePort atribu√≠da automaticamente pelo provedor de nuvem para o LoadBalancer.

Se TYPE for NodePort (porque LoadBalancer n√£o √© suportado ou voc√™ o alterou):
O EXTERNAL-IP provavelmente ser√° <none>. A coluna PORT(S) mostrar√° o mapeamento, ex.: 8080:30080/TCP. Voc√™ usar√° o endere√ßo IP de um Node e a nodePort (ex.: 30080).
Para obter um IP de Node (use um IP externo se dispon√≠vel, caso contr√°rio, interno para clusters locais como Minikube):

kubectl get nodes -o wide

Passo 6: Acessar a Aplica√ß√£o Externamente üåê
Se estiver usando LoadBalancer com um EXTERNAL-IP:
Abra seu navegador ou use curl:

curl http://<EXTERNAL-IP-DO-GET-SVC>:8080

Exemplo: curl http://34.XXX.YYY.ZZZ:8080

Se estiver usando NodePort:
Acesse usando o IP de qualquer Node e a nodePort (ex.: 30080 de 8080:30080/TCP):

curl http://<IP_DO_NODE>:<NODE_PORT_DO_GET_SVC>

Exemplo: curl http://192.168.49.2:30080 (se 192.168.49.2 for um IP de node do Minikube e 30080 for a nodePort).

Voc√™ deve ver a mensagem "Hello world!" ou a p√°gina de boas-vindas do Nginx.

Passo 7: Escalar a Aplica√ß√£o (Opcional) üìà
Para alterar o n√∫mero de Pods em execu√ß√£o:

kubectl scale deployment hello-world-deployment --replicas=3

Verifique com kubectl get pods -l app=hello-world. Voc√™ deve ver 3 Pods.
O Service distribuir√° automaticamente o tr√°fego para os novos Pods.

Para reduzir a escala:

kubectl scale deployment hello-world-deployment --replicas=1

Passo 8: Limpeza üßπ
Para remover a aplica√ß√£o implantada e seus recursos do seu cluster:

kubectl delete service hello-world-service
kubectl delete deployment hello-world-deployment

Se voc√™ enviou uma imagem personalizada para um registro, talvez queira exclu√≠-la de l√° tamb√©m (passo manual atrav√©s da interface do registro).

Solu√ß√£o de Problemas Comuns üîç
ImagePullBackOff / ErrImagePull:

kubectl describe pod <nome-do-pod> para detalhes.

Verifique se o nome e a tag da imagem est√£o corretos em hello-deployment.yaml.

Certifique-se de que a imagem seja p√∫blica ou que o cluster tenha segredos de pull para registro privado.

Verifique a conectividade de rede dos nodes do cluster para o registro.

CrashLoopBackOff:

kubectl logs <nome-do-pod> para ver os logs do cont√™iner em busca de erros da aplica√ß√£o.

kubectl describe pod <nome-do-pod> para motivos de reinicializa√ß√£o.

Certifique-se de que containerPort no Deployment corresponda √† porta em que sua aplica√ß√£o realmente escuta.

Verifique as requisi√ß√µes/limites de recursos; a app pode estar sendo OOMKilled (Out Of Memory Killed).

Service N√£o Acess√≠vel / Connection Refused:

Verifique se selector em hello-service.yaml corresponde aos r√≥tulos nos Pods (app: hello-world).

Verifique se targetPort em hello-service.yaml corresponde a containerPort em hello-deployment.yaml E √† porta em que sua app dentro do cont√™iner escuta.

Para LoadBalancer, certifique-se de que EXTERNAL-IP esteja provisionado e n√£o <pending>.

Verifique as regras de firewall do provedor de nuvem se o IP do LoadBalancer estiver inacess√≠vel.

Para NodePort, certifique-se de que o firewall do node permita tr√°fego na nodePort.

kubectl describe service hello-world-service para eventos ou erros.

kubectl get endpoints hello-world-service - verifique se h√° IPs de Pods de backend saud√°veis listados. Caso contr√°rio, o seletor do servi√ßo ou a sa√∫de do Pod √© um problema.